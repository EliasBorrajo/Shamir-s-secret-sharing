# Shamir Secret Sharing üîë

> **ShamirSS**¬†is a platform-independent Java 17 CLI implementing Shamir‚Äôs¬†*(k, n)*¬†secret-sharing scheme. It can split any binary secret into¬†*N*¬†JSON shares and re-assemble it with any¬†*K*¬†of them. Two core tools are provided:
> * `GenerateParts` ‚ÄîSplits secrets into¬†`N`¬†distinct JSON shares. The secret can later be reconstructed from any *K* of them, thanks to Lagrange interpolation over GF(257).
> * `CryptFile` ‚Äî encrypts or decrypts any file using AES-256, where the encryption key is derived from the reconstructed secret using SHA-256.

> The project was developed as part of the 632-2**Mathematics continuous assessment (2023) at** HES-SO Valais-Wallis, and focuses on modular arithmetic, applied cryptography, and CLI-based software design in Java.

---

## üìö Project Description

In many situations, especially in cryptography and secure systems, it's risky to store a secret in a single place or entrust it to a single person. Shamir's Secret Sharing provides a way to divide a secret (e.g., a password, key, or private data) into multiple parts (shares), such that only a chosen number of those parts (threshold K out of N) are needed to reconstruct it. This enables secure collaboration, backup, or distribution of sensitive data.

This project includes two Java 17 command-line tools:

* `GenerateParts`: generates *n* shares of a secret with a threshold *t* using Shamir's (k, n) secret sharing.
* `CryptFile`: uses shares to AES-encrypt and decrypt files securely.

The secret is a randomly generated byte array. Shares are stored as JSON files. Files can only be encrypted or decrypted with the threshold number of correct shares.

---

## üß™ Technologies Used

| Type        | Name                   | Version |
| ----------- | ---------------------- | ------- |
| Language    | Java                   | 17      |
| Build Tool  | Maven                  | 3.x     |
| CLI Library | Picocli (command line) | 4.7.4   |
| JSON        | Gson                   | 2.10.1  |
| Encryption  | Javax.crypto           | AES     |
| Testing     | JUnit                  | 5.x     |
|             |                        |         |

---

## **üéØ** Learning Objectives

* Understand modular arithmetic over finite fields (GF(257))
* Implement Shamir's (k,n) threshold scheme
* Apply Lagrange interpolation in a discrete field
* Practice secure file encryption and secret reconstruction
* Build CLI tools with clean UX (picocli)
* Use Git and Maven in a collaborative project setup

---

## üîß Features

* Modular arithmetic and Lagrange interpolation over GF(257)
* Shamir's secret sharing (generation + reconstruction)
* AES encryption/decryption with share-based key retrieval
* Command-line interface using Picocli
* JSON-based persistent share format
* Environment variable `SHAMIR` used as default share directory
* Java Maven project with modular code

---

## üß† Language Paradigm Principles

* ‚úÖ Modular decomposition via OOP
* ‚úÖ CLI abstraction through interfaces
* ‚úÖ Mathematical modeling (field, polynomial, etc.)

### ‚ùå Error Handling

* Errors are surfaced to CLI with error messages
* Invalid threshold or incompatible shares are validated before computation
* Missing/invalid input args are handled via Picocli error flow

---

## **üèóÔ∏è**¬†Project Structure

### Architecture

* `ch.hesso.s3.math.*` ‚Äì finite field arithmetic, modular operations, inverse, and Lagrange interpolation logic
* `ch.hesso.s3.storage.*` ‚Äì reading and writing of share files in JSON format, using Gson for serialization and deserialization
* `GenerateParts.java` ‚Äì CLI app to split a secret
* `CryptFile.java` ‚Äì CLI app to encrypt/decrypt using shares

---

## üìò Documentation & Diagrams

* Javadoc auto-generated
* Two UML diagrams are provided:

**Simplified UML Diagram:**
![Simplified UML Diagram](https://github.com/EliasBorrajo/Shamir-s-secret-sharing/blob/master/diagramSimplified.jpg "Simplified UML Diagram")

**Complete UML Diagram:**
![Complete UML Diagram](https://github.com/EliasBorrajo/Shamir-s-secret-sharing/blob/master/diagram.jpg "Complete UML Diagram1")

---

## ‚úÖ Tests & Validation

* JUnit 5 used for:

  * Modular arithmetic
  * Lagrange interpolation
  * Secret splitting and recombination

---


## ‚úÖ Project Overview & Status Summary

| Area                                         | Status     | Achievements / Functionality                                                     | Suggested Improvements                                                              |
| -------------------------------------------- | ---------- | -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| üî¢ **Math Library (GF(257), Interpolation)** | ‚úÖ OK       | Custom GF(257) arithmetic and Lagrange interpolation implemented                 | Refactor `LagrangeInterpolation` class to be abstract                               |
| üîê **AES Encryption**                        | ‚úÖ OK       | AES encryption with SHA-256 key derived from reconstructed secret                | -                                                                                   |
| ‚öôÔ∏è **Share Generation & Decryption**         | ‚úÖ OK       | CLI tools for share generation, reconstruction, and decryption fully operational | -                                                                                   |
| üì¶ **Share Format**                          | ‚úÖ OK       | JSON format is clean, consistent, and reusable                                   | -                                                                                   |
| üìã **Input Validation**                      | ‚úÖ OK       | CLI args and threshold logic handled with Picocli and validation checks          | -                                                                                   |
| ‚ùå **Error Handling**                         | ‚úÖ OK       | Clear error messages via CLI, invalid inputs blocked                             | -                                                                                   |
| üß™ **Testing**                               | ‚úÖ OK       | Unit tests cover mathematical logic and functionality                            | Create exhaustive test cases to make future maintenance easier                      |
| üß© **Modularity / Structure**                | ‚úÖ OK       | Codebase organized by responsibility (math, CLI, storage)                        | -                                                                                   |
| üìù **Documentation**                         | ‚úÖ OK       | Well-commented code and UML diagrams provided                                    | -                                                                                   |

---

## üë§ Authors

* **Elias Borrajo**
* **Milena Lonfat**
* **Jonathan Bourquin**
* **Emilie Teodoro Do Nascimento**


---

***Project realized for the course*** `632-2 ‚Äì Math√©matiques (Projet contr√¥le continu)`
***Instructor: Jean-Luc Beuchat, HES-SO Valais-Wallis***
*Context: Java, modular arithmetic, secret sharing & cryptography in a math-focused coding project.*




---
<details>
  <summary>
    <h2>
      2 ¬∑ README original (FR)
    </h2>
  </summary>

<H2>Project Mathematics S.3</H2>
<H2>Introduction :</H2>
This project is the continuous assessment of the 3rd semester in IT at the HES-SO of Sierre.

<ul>
    <li>Students: <b>Milena Lonfat, Emilie Teodoro Do Nascimento, Jonathan Bourquin and Elias Borrajo.</b></li>
    <li>Professor: Jean-Luc Beuchat</li>
    <li>Course: 632-2 Mathematics</li>
</ul>



<H2>Functionality :</H2>
<h3>Tool 1 - Generate Parts</h3>
Java command line tool for generating and sharing a secret (Shamir's secret sharing)

Inputs: size of the secret, minimum number of shares to reconstruct the secret, total number of shares to generate

Outputs: the secret shares as well as any useful metadata for the reconstruction of the secret

<h3>Tool 2 - Crypt / Decrypt File</h3>
Command line java tool to encrypt and decrypt a document (text file, Word document,...) or an executable

Inputs: parts of the secret generated by the first tool (and possible metadata), message and operation to perform

Output: encrypted or decrypted message depending on the chosen operation



<H2>Objectives :</H2>
<ul>
    <li>Designing a mathematical library in Java</li>
    <li>Develop software based on mathematical libraries</li>
    <li>Apply the knowledge acquired in the first year programming courses</li>
</ul>



<H2>Manual :</H2>

<H3>Installation</H3>
Before use:
<ol>
    <li> Create an environment variable called "SHAMIR" specific to the user, 
         with the specific path on your machine to store the files. 
         Store them into a folder for an easier use. </li>
    <li> Java version to use : openJDK 17.0.1 </li>
</ol>

<H3>Use</H3>
<H4><u>Use 1: Accesing by console</u></H4>
<ul>
    <li>In the command prompt use the command "cd" to go in the directory where your jar is located</li>
    <li>Then use: java -jar "name".jar and enjoy</li>
</ul>

<H4><u>Use 2: Create a shortcut of the app</u></H4>
<ul>
    <li>Create a new text file containing "java -jar "name".jar", then register it as a ".bat" file</li>
    <li>Keep the ".bat" file in the same location as your ".jar" app</li>
    <li>Create a shortcut of this ".bat" file, and put it on your desktop</li>
    <li>Run your ".bat" file from the directory or with the shortcut and enjoy !</li>
</ul>

<H4>Tool 1 : Generate parts</H4>
<p>
The purpose of using this tool #1 is to generate shares containing codes in a file per person.

As input to this tool, you must give the number of shares you want to generate, the threshold of shares required to be able to reconstruct the secret with the codes, and a certain number of bytes which will be arbitrary between 16, 24 or 32.

The tool will generate the shares in the folder given via the environment variable when installing the app.
For each user, send him only a file of type "User_X.json".

After sending all the files to all the users, you can delete the folder generated by the app.
If you want to regenerate shares, make sure that the destination folder is already empty, that it does not contain any old undistributed shares.
</p>

<H4>Tool 2 : Encrypt & Decrypt</H4>
<p>
Tool #2 encrypts or decrypts a file, using the shares generated by tool #1.

As input it takes :
1) The path where the shares containing the codes to be assembled of each user are located.

2) The path where the file to be encrypted & decrypted is located.

3) You must specify when using the application if you want to encrypt "-e" the file or decrypt "-d" it

Notes:
The paths must be correct. A simple mistake can make the tool not work properly.
Example : 
``` C:\Users\myName\Desktop\ShamirsProjectStorage\User_1.json ```

The file to be encrypted can have any extension. .pdf .exe .pptx .txt, it does not matter.

Be careful!
Any file can be encrypted using shares.
But when decrypting the file, if you use a number of shares lower than the threshold you decided when generating the file, it will be impossible to decrypt the file.
So it is absolutely necessary to encrypt a file with a number of shares that is at least equal to the threshold. (nparts >= threshold).

In addition,
The same number of users is required to encrypt and decrypt the file.
Example:
‚ó¶ A secret is generated with a single t=3 and a number of shares m =5
‚ó¶ To encrypt, 3 out of 5 shares are needed to reconstruct the key (e.g. users 2, 3 and 4)
‚ó¶ To decrypt, one also needs 3 out of 5 shares, but not necessarily the same as for encryption (e.g. users 1, 4 and 5)


</p>


<H2>Mathematic library</H2>
The mathematical library is in the "ModularArithmetic.java" class and "LagrangeInterpolation.java"

<H3>ModularArithmetic.java</H3>
The "ModularArithmetic.java" is the class that will allow us to perform calculations using operations (methods) such as:
 addition, subtraction, multiplication, division, power, greatest common divisor, isPrime and modular inverse Euclidean algorithm.
As we can‚Äôt use the class bigInteger we had to initialized a modulo to 257 wich is the first prime number after 256.

For the addition, subtraction, and multiplication we use the "Math.floorMod" that returns the floor modulus of the int argument.

<H4>Division</H4>
We calculate : a * multiplicative inverse of b

<H4>Power - Never used for the project</H4>
If the exponent is <= 0 an arithmeticException is throw because the power can not be <= 0 it should be minimum 1 else we use a loop and the multiplication we created to calculate it.

<H4>Greatest common divisor</H4>
If b = 0 it return a.
Else it return the greatest common divisor of b and a modulo b.

<H4>IsPrime</H4>
Calculate if a number is prime or not, returns ture if it‚Äôs a prime number, false if it‚Äôs not.

<H4>Modular Multiplicative inverse</H4>
Multiplicative inverse of A modulo M
<ol>
    <li>Greatest common divisor GCD of value(a) & modulo(b). value >= modulo</li>
    <li>Coefficient of bezout set of Z : ax + by = g = gcd</li>
    <li>For modulo prime number & value(a) set of Z modulo base, replace in the equation a by m : mx + by = 1 --> return y = multiplicative inverse.</li>
</ol>
return the modular inverse of the value

<H3>LagrangeInterpolation.java</H3>
<p>The ¬´ LagrangeInterpolation.java ¬ª used to perform a Lagrange interpolation on an array of points.</p>
<ul>
    <li>Polynomial Interpolation: interpolation of a data set by the polynomial of lowest possible degree.</li>
    <li>Consider a set of k points (x0, y0), (x1, y1), ‚Ä¶, (xk-1, yk-1) so that all values xi are distinct.</li>
    <li>There exists only one polynomial f(x) so that degree of f ‚â§ k - 1 and f(xi) = yi , ‚àÄi ‚àà{ 0, 1, ‚Ä¶, k - 1 }</li>
</ul>

Our method lagrange has two parameters Point[] f that is our "array of type Point" and "int n" that is our threshold.

With the call of our methods: division, multiplication, subtraction and addition create in our class modularArithmetic.java we can calculate it.

In a first for loop we compute the individual terms: term = f[i].y.

In a second for loop if j is different from i we calculate term= term * f[j].x / (f[i].x - f[j].x)

We calculate result += term and at the end return an int result.



<H2>Synthesis :</H2>
<table>
    <tr>
        <th></th>
        <th>Works</th>
        <th>Improvements</th>
        <th>Errors</th>
    </tr>
    <tr>
        <td>Generation parts</td>
        <td>OK</td>
        <td></td>
        <td>None</td>
    </tr>
    <tr>
        <td>Encrypt</td>
        <td>OK</td>
        <td></td>
        <td>None</td>
    </tr>
    <tr>
        <td>Decrypt</td>
        <td>OK</td>
        <td></td>
        <td>None</td>
    </tr>
    <tr>
        <td>Mathematic library</td>
        <td>OK</td>
        <td>Change the class lagrange interpolation to an abstract class</td>
        <td>None</td>
    </tr>
    <tr>
        <td>Picocli</td>
        <td>OK</td>
        <td></td>
        <td>None</td>
    </tr>
    <tr>
        <td>Testing</td>
        <td>OK</td>
        <td>Create each use case possible & imaginable to help maintaining it easier</td>
        <td>None</td>
    </tr>
    <tr>
       <td>Other</td>
       <td>-</td>
       <td>create an User interface outside the console to be more user friendly with our customer</td>
       <td>-</td>
    </tr>
</table>



  
</details>





